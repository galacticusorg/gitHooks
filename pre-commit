#!/usr/bin/env perl
use strict;
use warnings;
use lib $ENV{'GALACTICUS_EXEC_PATH'}."/perl";
use Term::ANSIColor;
use File::Slurp qw(slurp);
use File::Which;
use File::Temp;
use XML::Simple;
use XML::SAX::ParserFactory;
use XML::Validator::Schema;
use Data::Dumper;
use Galacticus::Build::SourceTree;

# Pre-commit hook for Git repos.
# Andrew Benson (28-July-2021)

# Get the ref of the current staged files.
my $ref = `git rev-parse --verify 'HEAD^{commit}'`;
$ref = "4b825dc642cb6eb9a060e54bf8d69288fbee4904" # SHA for an empty repo.
    unless ( $? == 0 );
# Get a list of all staged files, along with their status.
my @stagedFiles;
open(my $staged,"git diff-index --cached --diff-filter=ACMRD --ignore-submodules ".$ref." |");
while ( my $line = <$staged> ) {
    chomp($line);
    my @columns = split(" ",$line);
    push(
    	@stagedFiles,
    	{
	    sha      => $columns[3],
    	    status   => $columns[4],
    	    fileName => $columns[5]
    	}
    	);
}
close($staged);

# Extract files to be commited.
foreach my $stagedFile ( @stagedFiles ) {
    (my $suffix = $stagedFile->{'fileName'}) =~ s/.*(\.[^\.]+)$/$1/;
    my $tmpFile = File::Temp->new( UNLINK => 0, SUFFIX => $suffix);
    $stagedFile->{'tmpFileName'} = $tmpFile->filename();
    close($tmpFile);
    system("git cat-file blob ".$stagedFile->{'sha'}." > ".$stagedFile->{'tmpFileName'});
}

# Fortran static analysis checks.
my $fortranStaticCheck = 1;
foreach my $stagedFile ( @stagedFiles ) {
    next
	unless ( $stagedFile->{'fileName'} =~ m/\.F90$/ );
    # Parse the file.
    my $tree = &Galacticus::Build::SourceTree::ParseFile($stagedFile->{'tmpFileName'});
    # Walk the tree.
    my $node  = $tree;
    my $depth = 0;
    my $fileName;
    while ( $node ) {
	if ( $node->{'type'} eq "declaration" ) {
	    foreach my $declaration ( @{$node->{'declarations'}} ) {
		if ( $node->{'parent'}->{'type'} eq "type" && ( $declaration->{'intrinsic'} eq "type" || $declaration->{'intrinsic'} eq "class" ) && grep {$_ eq "pointer"} @{$declaration->{'attributes'}} ) {
		    # class/type pointers in derived types should be null initialized.
		    for(my $i=0;$i<scalar(@{$declaration->{'variables'}});++$i) {
			next
			    if ( $declaration->{'variables'}->[$i] =~ m/=>null\(\)$/ );
			(my $typeName = $node->{'parent'}->{'opener'}) =~ s/.*::\s*([a-zA-Z0-9_]+).*/$1/;
			chomp($typeName);
			print color('bold yellow')."⚠ ".color('reset')."Pointer variable '".$declaration->{'variableNames'}->[$i]."' in type '".$typeName."' is not null initialized\n";
			$fortranStaticCheck = 0;
		    }
		}
	    }
	}
	# Walk to the next node in the tree.
	$node = &Galacticus::Build::SourceTree::Walk_Tree($node,\$depth);
    }
}
if ( $fortranStaticCheck ) {
    print color('bold green')."✔ ".color('reset')."Fortran static analysis\n";
} else {
    print color('bold red')."✕ ".color('reset')."Fortran static analysis\n";
    exit 1;
}
    
# Test Perl scripts compile and are executable.
foreach my $stagedFile ( @stagedFiles ) {
    next
	if ( $stagedFile->{'status'} eq "D" );
    next
	unless ( $stagedFile->{'fileName'} =~ m/\.p[lm]$/ );
    # Perl scripts must be executable.
    if ( $stagedFile->{'fileName'} =~ m/\.pl$/ ) {
	if ( ! -x $stagedFile->{'fileName'} ) {
	    print color('bold red')."✕ ".color('reset')."Perl script is not executable (".$stagedFile->{'fileName'}.")\n";
	    exit 1;
	}
    }
    # Perl scripts and modules must compile.
    system("perl -c ".$stagedFile->{'tmpFileName'}." &> /dev/null");
    if ( $? != 0 ) {
	print color('bold red')."✕ ".color('reset')."Perl script/module does not compile (".$stagedFile->{'fileName'}.")\n";
	exit 1;
    }
}
print color('bold green')."✔ ".color('reset')."Perl scripts\n";

# Test XML files are valid.
foreach my $stagedFile ( @stagedFiles ) {
    next
	if ( $stagedFile->{'status'} eq "D" );
    next
	unless ( $stagedFile->{'fileName'} =~ m/\.(xml|xsd)$/ );
    system("xmllint --noout ".$stagedFile->{'tmpFileName'});
   if ( $? != 0 ) {
	print color('bold red')."✕ ".color('reset')."XML file is invalid (".$stagedFile->{'fileName'}.")\n";
	exit 1;
    }
    my $lineNumber = 0;
    open(my $xmlFile,$stagedFile->{'tmpFileName'});
    while ( my $line = <$xmlFile> ) {
	++$lineNumber;
	if ( $line =~ m/[^[:ascii:]]/ ) {
	    $line =~ s/([^[:ascii:]]+)/\e[31m$1\e[0m/g;
	    print $line;
	    print color('bold red')."✕ ".color('reset')."XML file has non-ascii character (".$stagedFile->{'fileName'}.":".$lineNumber.")\n";
	    exit 1;
	}
    }
    close($xmlFile);
}
print color('bold green')."✔ ".color('reset')."XML files\n";

# Test YAML files are valid.
if ( which('yamllint' ) ) {
    foreach my $stagedFile ( @stagedFiles ) {
	next
	    if ( $stagedFile->{'status'} eq "D" );
	next
	    unless ( $stagedFile->{'fileName'} =~ m/\.yml$/ );
	system("yamllint ".$stagedFile->{'tmpFileName'}." > /dev/null 2>&1");
	if ( $? != 0 ) {
	    print color('bold red')."✕ ".color('reset')."YAML file is invalid (".$stagedFile->{'fileName'}.")\n";
	    exit 1;
	}
    }
    print color('bold green')."✔ ".color('reset')."YAML files\n";
}
     
# Test XML and LaTeX fragments.
my $xml = new XML::Simple();
foreach my $stagedFile ( @stagedFiles ) {
    next
	if ( $stagedFile->{'status'} eq "D" );
    next
	unless ( $stagedFile->{'fileName'} =~ m/\.(F90|Inc)$/ );
    my $inDirective       = 0;
    my $inXML             = 0;
    my $inLaTeX           = 0;
    my $lineNumber        = 0;
    my $directiveRoot        ;
    my $rawCode              ;
    my $rawDirective         ;
    my $rawLaTeX             ;
    my $strippedDirective    ;
    open(my $code,$stagedFile->{'tmpFileName'});
    while ( my $line = <$code> ) {
	# Detect the end of a LaTeX section and change state.
	$inLaTeX = 0
	    if ( $line =~ m/^\s*!!\}/ );
	# Detect the end of an XML section and change state.
	$inXML = 0
	    if ( $line =~ m/^\s*!!\]/ );
	# Process LaTeX blocks.
	$rawLaTeX .= $line
	    if ( $inLaTeX );
	if ( defined($rawLaTeX) && ! $inLaTeX ) {
	    my $LaTeXLog = &testLaTeX($rawLaTeX);
	    if ( defined($LaTeXLog) ) {
	     	print color('bold red')."✕ ".color('reset')."LaTeX fragment compilation failed (".$stagedFile->{'fileName'}.":".$lineNumber."):\n".$LaTeXLog;
	     	exit 1;
	    }
	    undef($rawLaTeX);
	}
	# Process XML blocks.
	my $isDirective  = 0;
	my $endDirective = 0;
	(my $strippedLine = $line) =~ s/^\s*\!<\s*//;
	if ( $inXML ) {
	    # Determine if line is a directive line.
	    $isDirective    = 1
		if ( $strippedLine =~ m/^\s*\<([^\s\>\/]+)/ || $inDirective == 1 );
	    $directiveRoot = $1
		if ( $isDirective == 1 && $inDirective == 0 );		
	    # Catch the end of directives.
	    $endDirective = 1
		if ( $isDirective == 1 && $strippedLine =~ m/\s*\<\/$directiveRoot\>/ );
	    $endDirective = 1
		if ( $isDirective == 1 && $inDirective == 0 && ( $strippedLine =~ m/\s*\<$directiveRoot\s.*\/\>/ || $strippedLine =~ m/\s*\<$directiveRoot\/\>/ ) );
	    # Record whether we are currently in or out of a directive.
	    $inDirective = 1
		if ( $isDirective == 1 );
	}
	# Accumulate raw text.
	if ( $inDirective ) {
	    $rawDirective      .= $line;
	    $strippedDirective .= $strippedLine;
	} elsif ( $line !~ m/^\s*!!(\[|\])/ ) {
	    $rawCode           .= $line;
	}
	# Process code and directive blocks as necessary.
	if ( ( $inDirective == 0 || eof($code) || $endDirective ) && $rawDirective ) {
	    # Attempt to parse the directive XML.
	    my $directive = eval{$xml->XMLin($strippedDirective, keepRoot => 1)};
	    if ( $@ ) {
		print color('bold red')."✕ ".color('reset')."Parsing XML fragment failed (".$stagedFile->{'fileName'}.":".$lineNumber.")\n".$@."\n";
		print $strippedDirective;
		exit(1);
	    }
	    my $directiveName = (keys %{$directive})[0];
	    # Validate the directive if possible.
	    if ( -e $ENV{'GALACTICUS_EXEC_PATH'}."/schema/".$directiveName.".xsd" ) {
		my $validator = XML::Validator::Schema->new(file => $ENV{'GALACTICUS_EXEC_PATH'}."/schema/".$directiveName.".xsd");
		my $parser    = XML::SAX::ParserFactory->parser(Handler => $validator); 
		eval { $parser->parse_string($strippedDirective) };
		if ( $@ ) {
		    print color('bold red')."✕ ".color('reset')."XML fragment validation failed (".$stagedFile->{'fileName'}.":".$lineNumber."):\n".$@."\n";
		    exit 1;
		}
	    }
	    # Look for a "description" element in the directive - this should be LaTeXable.
	    if ( exists($directive->{$directiveName}->{'description'}) ) {
		my $LaTeXLog = &testLaTeX($directive->{$directiveName}->{'description'});
		if ( defined($LaTeXLog) ) {
		    print color('bold red')."✕ ".color('reset')."XML LaTeX description compilation failed (".$stagedFile->{'fileName'}.":".$lineNumber."):\n".$LaTeXLog;
		    exit 1;
		}
	    }
	    # Reset the raw directive text.
	    $inDirective = 0;
	    undef($rawDirective     );
	    undef($strippedDirective);
	}
	# Detect the start of an XML section and change state.
	$inXML = 1
	    if ( $line =~ m/^\s*!!\[/ );
	# Detect the start of a LaTeX section and change state.
	$inLaTeX = 1
	    if ( $line =~ m/^\s*!!\{/ );
	# Increment line number count.
	++$lineNumber;
    }
    close($code);
}
print color('bold green')."✔ ".color('reset')."XML fragments\n";
print color('bold green')."✔ ".color('reset')."LaTeX fragments\n";

# Test Perl scripts/modules and source files have no debugging statements in them.
foreach my $stagedFile ( @stagedFiles ) {
    next
	if ( $stagedFile->{'status'} eq "D" );
    next
	unless ( $stagedFile->{'fileName'} =~ m/\.(pl|pm|F90|Inc|h|c|cpp)$/ );
    my $lineNumber = 0;
    open(my $code,$stagedFile->{'tmpFileName'});
    while ( my $line = <$code> ) {
	++$lineNumber;
	if ( $line =~ m/AJB HACK/ ) {
	    print color('bold red')."✕ ".color('reset')."Debugging statement remains (".$stagedFile->{'fileName'}.":".$lineNumber."):\n";
	    exit 1; 
	}
    }
    close($code);
}
print color('bold green')."✔ ".color('reset')."Debugging statements removed\n";

# Remove temporary files.
unlink(map {$_->{'tmpFileName'}} @stagedFiles);

exit 0;

sub testLaTeX {
    # Test that a LaTeX fragment compiles.
    my $rawLaTeX = shift();
    $rawLaTeX =~ s/&amp;/&/g;
    $rawLaTeX =~ s/&lt;/>/g;
    open(my $LaTeX,">doc/frag.tex");
    print $LaTeX "\\documentclass[letterpaper,10pt,headsepline]{scrbook}\n";
    print $LaTeX "\\usepackage{natbib}\n";
    print $LaTeX "\\usepackage{epsfig}\n";
    print $LaTeX "\\usepackage[acronym]{glossaries}\n";
    print $LaTeX "\\usepackage[backref,colorlinks]{hyperref}\n";
    print $LaTeX "\\usepackage{amssymb}\n";
    print $LaTeX "\\usepackage{amsmath}\n";
    print $LaTeX "\\input{".$ENV{'GALACTICUS_EXEC_PATH'}."/doc/commands}\n";
    print $LaTeX "\\input{".$ENV{'GALACTICUS_EXEC_PATH'}."/doc/Glossary}\n";
    print $LaTeX "\\newcommand{\\docname}{tmp}\n";
    print $LaTeX "\\begin{document}\n";
    print $LaTeX $rawLaTeX;
    print $LaTeX "\\end{document}\n";
    close($LaTeX);
    system("cd doc; pdflatex -halt-on-error frag > frag.tmp");
    my $log = $? ? slurp("doc/frag.log") : undef();
    foreach my $fileName ( "frag.tex", "frag.pdf", "frag.log", "frag.aux", "frag.tmp", "frag.glo" ) {
	unlink("doc/".$fileName)
	    if ( -e "doc/".$fileName );
    }
    return $log;
}
